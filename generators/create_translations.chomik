#!/usr/local/bin/chomik

#
# This script creates a file ../generated/list_of_actions.chomik and fills it with the actions.
# For each action we have a boolean (whether it has been processed) and a string - the action's name when performed by Gotrek.

# It also creates a file ../generated/list_of_informations.chomik and fills it with the informations.
#


include "../chomik/user_defined_types.chomik"
include "../chomik/global_variables.chomik"
include "../chomik/global_streams.chomik"
include "process_translations_for_actions.chomik"



variable calculate Gotrek action text for current possible decision (B:boolean):code;
let calculate Gotrek action text for current possible decision true=value code {};
let calculate Gotrek action text for current possible decision false=value code
{
    <compare "action" <current possible decision> no_action>;
    <check if Gotrek is going to do nothing <the compare result>>;

    <check if Gotrek is going to go to (A:place)>;
    <check if Gotrek is going to attack (A:person)>;
    <check if Gotrek is going to propose (A:person) to exchange weapons>;
    <check if Gotrek is going to accept (A:person) proposal to exchange weapons>;
            #<check if Gotrek is going to tell (A:person) that (B:information)>;
    <check if Gotrek is going to ask (A:person) to (B:action)>;
    <check if Gotrek is going to ask (A:person) what (B:person) function is>;
    <check if Gotrek is going to ask (A:person) what (B:person) weapon is>;
    <check if Gotrek is going to ask (A:person) whether (B:person) is a liar>;
    <check if Gotrek is going to answer (A:person) that (B:person) is a liar is (ANSWER:boolean)>;
    <check if Gotrek is going to answer (A:person) that (B:person) weapon is (W:weapon) is (ANSWER:boolean)>;
    <check if Gotrek is going to answer (A:person) that (B:person) function is (F:function) is (ANSWER:boolean)>;
};




variable Gotrek calculation counter: integer;

variable calculate Gotrek action text (ACTION:action):code;
let calculate Gotrek action text (ACTION:action)=value code
{
    let current possible decision = value action [(ACTION:action)];
    
    <print "check how to translate Gotrek's decision" <current possible decision> "into text (" <Gotrek calculation counter> ").">;    
        
    <calculate Gotrek action text for current possible decision <<current possible decision> has been translated>>;
            
    <add "integer" <Gotrek calculation counter> 1>;
    let Gotrek calculation counter = <the add result "integer">;
    
};


variable check if current information is current guest 2 is in current place (C:compare_result):code;
let check if current information is current guest 2 is in current place lower = value code {};
let check if current information is current guest 2 is in current place greater = value code {};
let check if current information is current guest 2 is in current place equal = value code
{
    let the set to stream stream index = <my concatenating stream index>;
    <set to stream "">;
    
    let the print target stream index =  <the set to stream stream index>;
    let the print end of line = value string "";
    let the print separator = value string "";
    <print <from the Gotrek point of view who is <current guest 2>> "is in" <current place> ".">;    
    let the print target stream index = value integer 0;    # standard output
    let the print end of line = value string "\n";
    let the print separator = value string " ";

    let the get from stream stream index = <the set to stream stream index>;
    <get from stream>;
    
    let Gotrek information text <current information> when talking to <current guest> = <the get from stream result>;
        
    let <current information> has been translated when talking to <current guest> = value boolean true;
    let information complexity <current information> = value integer 1;
};


variable check if current information is current guest 2 has current function (C:compare_result):code;
let check if current information is current guest 2 has current function lower = value code {};
let check if current information is current guest 2 has current function greater = value code {};
let check if current information is current guest 2 has current function equal = value code 
{
    let the set to stream stream index = <my concatenating stream index>;
    <set to stream "">;
    
    let the print target stream index =  <the set to stream stream index>;
    let the print end of line = value string "";
    let the print separator = value string "";
    <print <from the Gotrek point of view who is <current guest 2>> " has function " <current function> ".">;    
    let the print target stream index = value integer 0;    # standard output
    let the print end of line = value string "\n";
    let the print separator = value string " ";

    let the get from stream stream index = <the set to stream stream index>;
    <get from stream>;
    
    let Gotrek information text <current information> when talking to <current guest> = <the get from stream result>;
        
    let <current information> has been translated when talking to <current guest> = value boolean true;
    let information complexity <current information> = value integer 1;
};



variable check if current information is current guest 2 has current weapon (C:compare_result):code;
let check if current information is current guest 2 has current weapon lower = value code {};
let check if current information is current guest 2 has current weapon greater = value code {};
let check if current information is current guest 2 has current weapon equal = value code 
{
    let the set to stream stream index = <my concatenating stream index>;
    <set to stream "">;
    
    let the print target stream index =  <the set to stream stream index>;
    let the print end of line = value string "";
    let the print separator = value string "";
    <print <from the Gotrek point of view who is <current guest 2>> " has weapon " <current weapon> ".">;    
    let the print target stream index = value integer 0;    # standard output
    let the print end of line = value string "\n";
    let the print separator = value string " ";

    let the get from stream stream index = <the set to stream stream index>;
    <get from stream>;
    
    let Gotrek information text <current information> when talking to <current guest> = <the get from stream result>;
        
    let <current information> has been translated when talking to <current guest> = value boolean true;
    let information complexity <current information> = value integer 1;
};


variable check if current information is current guest 2 can see current guest 3 (C:compare_result):code;
let check if current information is current guest 2 can see current guest 3 lower = value code {};
let check if current information is current guest 2 can see current guest 3 greater = value code {};
let check if current information is current guest 2 can see current guest 3 equal = value code 
{
    let the set to stream stream index = <my concatenating stream index>;
    <set to stream "">;
    
    let the print target stream index =  <the set to stream stream index>;
    let the print end of line = value string "";
    let the print separator = value string "";
    <print <from the Gotrek point of view who is <current guest 2>> " can see " <from the Gotrek point of view who is <current guest 3>> ".">;    
    let the print target stream index = value integer 0;    # standard output
    let the print end of line = value string "\n";
    let the print separator = value string " ";

    let the get from stream stream index = <the set to stream stream index>;
    <get from stream>;
    
    let Gotrek information text <current information> when talking to <current guest> = <the get from stream result>;
        
    let <current information> has been translated when talking to <current guest> = value boolean true;
    let information complexity <current information> = value integer 1;
};

variable check if current information is current guest 2 is a liar (C:compare_result):code;
let check if current information is current guest 2 is a liar lower = value code {};
let check if current information is current guest 2 is a liar greater = value code {};
let check if current information is current guest 2 is a liar equal = value code
{
    let the set to stream stream index = <my concatenating stream index>;
    <set to stream "">;
    
    let the print target stream index =  <the set to stream stream index>;
    let the print end of line = value string "";
    let the print separator = value string "";
    <print <from the Gotrek point of view who is <current guest 2>> " is a liar.">;    
    let the print target stream index = value integer 0;    # standard output
    let the print end of line = value string "\n";
    let the print separator = value string " ";

    let the get from stream stream index = <the set to stream stream index>;
    <get from stream>;
    
    let Gotrek information text <current information> when talking to <current guest> = <the get from stream result>;
        
    let <current information> has been translated when talking to <current guest> = value boolean true;
    let information complexity <current information> = value integer 1;
};


variable check if current information is current guest 2 has asked current guest 3 to current action (C:compare_result):code;
let check if current information is current guest 2 has asked current guest 3 to current action lower = value code {};
let check if current information is current guest 2 has asked current guest 3 to current action greater = value code {};
let check if current information is current guest 2 has asked current guest 3 to current action equal = value code 
{
    let the set to stream stream index = <my concatenating stream index>;
    <set to stream "">;
    
    let the print target stream index =  <the set to stream stream index>;
    let the print end of line = value string "";
    let the print separator = value string "";
    <print  <from the Gotrek point of view who is <current guest 2>> " has asked " 
            <from the Gotrek point of view who is <current guest 3>> " to " <Gotrek action text <current action>> ".">;    
    let the print target stream index = value integer 0;    # standard output
    let the print end of line = value string "\n";
    let the print separator = value string " ";

    let the get from stream stream index = <the set to stream stream index>;
    <get from stream>;
    
    let Gotrek information text <current information> when talking to <current guest> = <the get from stream result>;
        
    let <current information> has been translated when talking to <current guest> = value boolean true;
        
    <add "integer" <action complexity <current action>> 1>;    
    let information complexity <current information> = <the add result "integer">;
};





variable check if the current information is (A:person) is in (B:place):code;
let check if the current information is (A:person) is in (B:place)=value code
{
    let current guest 2 = value person [(A:person)];
    let current place = value place [(B:place)];
    let current information pattern = value information <current guest 2> is in <current place>;

    <compare "information" <current information> <current information pattern>>;
    <check if current information is current guest 2 is in current place <the compare result>>;    
};



variable check if the current information is (A:person) has function (B:function):code;
let check if the current information is (A:person) has function (B:function)=value code
{
    let current guest 2 = value person [(A:person)];
    let current function = value function [(B:function)];
    let current information pattern = value information <current guest 2> has function <current function>;
    
    <compare "information" <current information> <current information pattern>>;
    <check if current information is current guest 2 has current function <the compare result>>;
};


variable check if the current information is (A:person) has weapon (B:weapon):code;
let check if the current information is (A:person) has weapon (B:weapon) = value code
{
    let current guest 2 = value person [(A:person)];
    let current weapon = value weapon [(B:weapon)];
    let current information pattern = value information <current guest 2> has weapon <current weapon>;
    
    <compare "information" <current information> <current information pattern>>;
    <check if current information is current guest 2 has current weapon <the compare result>>;    
};


variable check if the current information is (A:person) can see (B:person):code;
let check if the current information is (A:person) can see (B:person) = value code
{
    let current guest 2 = value person [(A:person)];
    let current guest 3 = value person [(B:person)];
    let current information pattern = value information <current guest 2> can see <current guest 3>;
    
    <compare "information" <current information> <current information pattern>>;
    <check if current information is current guest 2 can see current guest 3 <the compare result>>;    
};

variable check if the current information is (A:person) is a liar:code;

let check if the current information is (A:person) is a liar = value code
{
    let current guest 2 = value person [(A:person)];
    let current information pattern = value information <current guest 2> is a liar;
    
    <compare "information" <current information> <current information pattern>>;
    <check if current information is current guest 2 is a liar <the compare result>>;    
};


variable check if the current information is (A:person) has asked (B:person) to (C:action):code;
let check if the current information is (A:person) has asked (B:person) to (C:action)=value code
{
    let current guest 2 = value person [(A:person)];
    let current guest 3 = value person [(B:person)];
    let current action = value action [(C:action)];    
    let current information pattern = value information <current guest 2> has asked <current guest 3> to <current action>;

    <compare "information" <current information> <current information pattern>>;
    <check if current information is current guest 2 has asked current guest 3 to current action <the compare result>>;        
};



variable calculate Gotrek information text (I:information) when talking to (P:person):code;
let calculate Gotrek information text (I:information) when talking to (P:person)=value code
{
    let current information = value information [(I:information)];
    let current guest = value person [(P:person)];
    
    <print "check how to translate information" <current information> "into text (" <Gotrek calculation counter> ").">;    
    
    <check if the current information is (A:person) is in (B:place)>;
    <check if the current information is (A:person) has function (B:function)>;
    <check if the current information is (A:person) has weapon (B:weapon)>;
    <check if the current information is (A:person) can see (B:person)>;
    <check if the current information is (A:person) is a liar>;
    <check if the current information is (A:person) has asked (B:person) to (C:action)>;

    <add "integer" <Gotrek calculation counter> 1>;
    let Gotrek calculation counter = <the add result "integer">;    
};




variable all actions have been processed:boolean, all informations have been processed:boolean;

variable on Gotrek decision processed (V:boolean):code;
let on Gotrek decision processed false=value code
{
    let all actions have been processed = value boolean false;
};
let on Gotrek decision processed true=value code {};


variable on Gotrek information processed (V:boolean):code;
let on Gotrek information processed false=value code
{
    let all informations have been processed = value boolean false;
};
let on Gotrek information processed true = value code {};




variable check whether the action (ACTION:action) has been processed:code;
let check whether the action (ACTION:action) has been processed=value code
{
    let current possible decision = value action [(ACTION:action)];
    <on Gotrek decision processed <<current possible decision> has been translated>>;
};


variable check whether the information (INFORMATION:information) has been processed when talking to (P:person):code;
let check whether the information (INFORMATION:information) has been processed when talking to (P:person)=value code
{
    let current information = value information [(INFORMATION:information)];
    let current guest = value person [(P:person)];
    <on Gotrek information processed <<current information> has been translated when talking to <current guest>>>;
};


variable check whether all actions have been processed:code;
let check whether all actions have been processed=value code
{
    let all actions have been processed = value boolean true;
    
    <check whether the action (ACTION:action) has been processed>;        
    
    <print "all actions have been processed: " <all actions have been processed>>;
};


variable check whether all informations have been processed:code;
let check whether all informations have been processed=value code
{
    let all informations have been processed = value boolean true;
    
    <check whether the information (INFORMATION:information) has been processed when talking to (P:person)>;
    
    <print "all informations have been processed: " <all informations have been processed>>;
};




#
# here we calculate the action names if done by Gotrek
#
let Gotrek calculation counter = value integer 1;
<calculate Gotrek information text (INFORMATION:information) when talking to (PERSON:person)>;

let Gotrek calculation counter = value integer 1;
<calculate Gotrek action text (ACTION:action)>;

let Gotrek calculation counter = value integer 1;
<calculate Gotrek information text (INFORMATION:information) when talking to (PERSON:person)>;

let Gotrek calculation counter = value integer 1;
<calculate Gotrek action text (ACTION:action)>;

<check whether all actions have been processed>;
<check whether all informations have been processed>;

include "write_translations_files.chomik"

