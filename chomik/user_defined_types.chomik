#!/usr/local/bin/chomik

type person={Gotrek, Gwaigilion, Gerrudir, Pregor};
type place={Krakow, Warszawa, Wroclaw, Poznan, Gdansk};
type function={no_function,Czesnik, Krajczy, Skarbnik, Starosta, Kasztelan};
type weapon={no_weapon, sword, axe};
type tense={past,present,future};


type information={  (X:person) is in (T:tense) in (Y:place),                    
                    (X:person) has in (T:tense) function (Y:function),
                    (X:person) has in (T:tense) weapon (Y:weapon),                    
                    (X:person) can see in (T:tense) (Y:person),                    
                    (X:person) is a liar,                    
                    (X:person) tells in (T:tense) (Y:person) that (Z:information),
                    
                    (X:person) asks in (T:tense) (Y:person) to (Z:action),                    
                    (X:person) asks in (T:tense) (Y:person) what is in (T2:tense) (Z:person) function,                    
                    (X:person) asks in (T:tense) (Y:person) what is in (T2:tense) (Z:person) weapon,                    
                    (X:person) asks in (T:tense) (Y:person) whether (Z:person) is a liar,                    
                    (X:person) proposes in (T:tense) (Y:person) to exchange weapons,                  
                    
                    (X:person) refuses in (T:tense) (Y:person) proposal to (PROPOSAL:action),
                    (X:person) refuses in (T:tense) (Y:person) to reveal (Z:person) weapon,
                    (X:person) refuses in (T:tense) (Y:person) to reveal (Z:person) function,                    
                    (X:person) accepts in (T:tense) (Y:person) proposal to (PROPOSAL:action),                    
                    (X:person) accepts in (T:tense) (Y:person) proposal to exchange weapons,                    
                    (X:person) answers in (T:tense) (Y:person) that (Z:information),                    
                    (X:person) thinks in (T:tense) that (Y:information),
                    
                    not (X:information)};
                    
type action={no_action,                                             # does not depend on anything

            goto (X:place),                                         # depends on a place (that must be connected)
            tell (X:person) that (Y:information),                   # depends on a person (that must be present)
                        
            
            ask (X:person) to (Y:action),                           # depends on a person (that must be present)
            ask (X:person) what is in (T:tense) (Y:person) function,    
            ask (X:person) what is in (T:tense) (Y:person) weapon,
            ask (X:person) whether (Y:person) is a liar,
            propose (X:person) to exchange weapons,            
            
            answer (X:person) that (Y:person) is a liar is (ANSWER:boolean),
            answer (X:person) that (Y:person) weapon is in (T:tense) (WEAPON:weapon) is (ANSWER:boolean),
            answer (X:person) that (Y:person) function is in (T:tense) (FUNCTION:function) is (ANSWER:boolean),
            accept (X:person) proposal to (PROPOSAL:action),
            accept (X:person) proposal to exchange weapons,            
            
            refuse (X:person) proposal to (PROPOSAL:action),            
            refuse (X:person) to reveal (Y:person) weapon,
            refuse (X:person) to reveal (Y:person) function,
            refuse (X:person) to reveal whether (Y:person) is a liar,
            
            attack (X:person)
            };
            
type game_mode_type={title, game},
    game_phase_type={asking phase, answering phase, moving phase},
        possible_decisions_range=1..5,
        notification_texts_range=1..20,
        places_range=1..5,
        persons_range=1..4,
        Gotrek_animation_range=1..10;
        
        
type action_class={ actions that do not depend on anything, 
                    actions that depend on a place, 
                    actions that depend on a person proposals,
                    actions that depend on a person answers,
                    actions that depend on a person others};

                    
# Once we identified the random person present we can use this "subclass" to generate the actual actions.
# The term "subclass" has nothing to do with the "class" from the OOP. Instead, these enums identify
# certain subsets of the action set.

type action_depending_on_person_proposals_subclass={  
                                            actions ask person to action,
                                            actions ask person what is his function,
                                            actions ask person what is his weapon,
                                            actions ask person whether he is a liar,
                                            actions propose person to exchange weapons,
                                            actions attack person
                                            },
    action_depending_on_person_answers_subclass={
                                            actions answer person whether I am a liar,
                                            actions answer person what is my weapon,
                                            actions answer person what is my function,
                                            actions accept person proposal to do action,
                                            actions refuse person proposal to do action,
                                            actions refuse person question to reveal my weapon,
                                            actions refuse person question to reveal my function,
                                            actions accept person proposal to exchange weapons,
                                            actions attack person
                                            },
    action_depending_on_person_others_subclass={
                                            actions attack person,
                                            actions tell person that information
                                            };

type explanation_mode_type = { 
    normal explanation, 
    asking about being a liar explanation, 
    asking about weapon explanation,
    asking about function explanation,
    proposing weapon exchange to anybody explanation,
    proposing weapon exchange from anybody explanation,
    god mode explanation};                                            
                                                                                        
expand(2);


include "../chomik/successors.chomik"


variable not (X:boolean):boolean;
let not true=value boolean false;
let not false=value boolean true;



variable weapon bonus for (X:weapon):integer;
let weapon bonus for no_weapon=value integer 0;
let weapon bonus for axe=value integer 3;
let weapon bonus for sword=value integer 4; # sword is a little better than axe

variable from the computer talking to Gotrek point of view who is (X:person):string;
let from the computer talking to Gotrek point of view who is Gotrek=value string "yourself";
let from the computer talking to Gotrek point of view who is Gwaigilion=value string "Gwaigilion";
let from the computer talking to Gotrek point of view who is Gerrudir=value string "Gerrudir";
let from the computer talking to Gotrek point of view who is Pregor=value string "Pregor";

variable from the Gotrek point of view who is (X:person):string;
let from the Gotrek point of view who is Gotrek=value string "myself";
let from the Gotrek point of view who is Gwaigilion=value string "Gwaigilion";
let from the Gotrek point of view who is Gerrudir=value string "Gerrudir";
let from the Gotrek point of view who is Pregor=value string "Pregor";

variable from the Gotrek point of view how to say whether (X:person) is a liar:string;
let from the Gotrek point of view how to say whether (X:person) is a liar=value string "whether he is a liar";
let from the Gotrek point of view how to say whether Gotrek is a liar=value string "whether I am a liar";

variable from the Gotrek point of view how to say that (X:person) is a liar:string;
let from the Gotrek point of view how to say that (X:person) is a liar=value string "that he is a liar";
let from the Gotrek point of view how to say that Gotrek is a liar=value string "that I am a liar";

variable from the Gotrek point of view how to say that (X:person) is not a liar:string;
let from the Gotrek point of view how to say that (X:person) is not a liar=value string "that he is not a liar";
let from the Gotrek point of view how to say that Gotrek is not a liar=value string "that I am not a liar";


variable from the Gotrek point of view how to say what (X:person) weapon is:string;
let from the Gotrek point of view how to say what (X:person) weapon is=value string "what his weapon is";
let from the Gotrek point of view how to say what Gotrek weapon is=value string "what my weapon is";

variable from the Gotrek point of view how to say what (X:person) function is:string;
let from the Gotrek point of view how to say what (X:person) function is=value string "what his function is";
let from the Gotrek point of view how to say what Gotrek function is=value string "what my function is";
