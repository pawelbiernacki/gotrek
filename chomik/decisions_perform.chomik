#!/usr/local/bin/chomik


variable current person goto current place (X:compare_result):code;
let variable current person goto current place lower=value code {};
let variable current person goto current place greater=value code {};
let variable current person goto current place equal=value code 
{
    let variable location of <current person>=<current place>;
    
    execute <print <current person> "has moved to" <location of <current person>>>;
    
    let variable decision of <current person>=value action no_action;    
};


variable current person tells current guest that current information (X:compare_result):code;
let variable current person tells current guest that current information lower = value code {};
let variable current person tells current guest that current information greater = value code {};
let variable current person tells current guest that current information equal = value code 
{
    execute <print <current person> "tells" <current guest> "that" <current information>>;
    
    let variable decision of <current person>=value action no_action;
};


variable current person asks current guest to current action (X:compare_result):code;
let variable current person asks current guest to current action lower = value code {};
let variable current person asks current guest to current action greater = value code {};
let variable current person asks current guest to current action equal = value code 
{
    execute <print <current person> "asks" <current guest> "to" <current action>>;
    
    let variable decision of <current person>=value action no_action;
};


variable current person asks current guest what is his function (X:compare_result):code;
let variable current person asks current guest what is his function lower = value code {};
let variable current person asks current guest what is his function greater = value code {};
let variable current person asks current guest what is his function equal = value code 
{
    execute <print <current person> "asks" <current guest> "what is his function">;
    
    let <current guest> thinks that <current person> has asked him what is his function=value boolean true;
    
    let variable decision of <current person>=value action no_action;
};


variable current person asks current guest what is his weapon (X:compare_result):code;
let variable current person asks current guest what is his weapon lower = value code {};
let variable current person asks current guest what is his weapon greater = value code {};
let variable current person asks current guest what is his weapon equal = value code 
{
    execute <print <current person> "asks" <current guest> "what is his weapon">;
    
    let <current guest> thinks that <current person> has asked him what is his weapon=value boolean true;
    
    let variable decision of <current person>=value action no_action;
};

variable current person asks current guest whether he is a liar (X:compare_result):code;
let variable current person asks current guest whether he is a liar lower = value code {};
let variable current person asks current guest whether he is a liar greater = value code {};
let variable current person asks current guest whether he is a liar equal = value code 
{
    execute <print <current person> "asks" <current guest> "whether he is a liar">;
    
    let <current guest> thinks that <current person> has asked him whether he is a liar = value boolean true;
    
    
    let variable decision of <current person>=value action no_action;
};

include "../chomik/notify_gotrek.chomik"
include "../chomik/resolve_the_events.chomik"


variable current person attacks current guest (X:compare_result):code;
let variable current person attacks current guest lower = value code {};
let variable current person attacks current guest greater = value code {};
let variable current person attacks current guest equal = value code 
{
    execute <print <current person> "attacks" <current guest>>;
    
    # calculate the efficiency of both fighters    
    
    # first current person
    let the read from stream source stream index = <my efficiency bonus generator index>;
    <read from stream "integer">;            
    let current efficiency bonus = <the read from stream result "integer">;
        
    <print <current person> "uses" <weapon of <current person>>>;
    
    <add "integer" <current efficiency bonus> <weapon bonus for <weapon of <current person>>>>;
    let current efficiency bonus = <the add result "integer">;    
    
            
    <add "integer" <strength of <current person>> <current efficiency bonus>>;
    let efficiency of <current person>=<the add result "integer">;
        
    
    # now current guest
    <read from stream "integer">; 
    let current efficiency bonus = <the read from stream result "integer">;
        
    <print <current guest> "uses" <weapon of <current guest>>>;
    
    <add "integer" <current efficiency bonus> <weapon bonus for <weapon of <current guest>>>>;
    let current efficiency bonus = <the add result "integer">;    
            
    <add "integer" <strength of <current guest>> <current efficiency bonus>>;
    let efficiency of <current guest>=<the add result "integer">;
    
    # now compare the efficiencies of both fighters
    <compare "integer" <efficiency of <current person>> <efficiency of <current guest>>>;
        
    <resolve the fight <the compare result>>;
                
    let decision of <current person>=value action no_action;
};

variable current person proposes current guest to exchange weapons (X:compare_result):code;
let variable current person proposes current guest to exchange weapons lower = value code {};
let variable current person proposes current guest to exchange weapons greater = value code {};
let variable current person proposes current guest to exchange weapons equal = value code 
{
    execute <print <current person> "proposes" <current guest> "to exchange weapons">;
    
    let variable <current guest> thinks that <current person> has proposed him to exchange weapons=value boolean true;
        
    let variable decision of <current person>=value action no_action;
    
    <resolve the proposal to exchange weapons>;
};


variable current person accepts current guest proposal to exchange weapons (X:compare_result):code;
let current person accepts current guest proposal to exchange weapons lower = value code {};
let current person accepts current guest proposal to exchange weapons greater = value code {};
let current person accepts current guest proposal to exchange weapons equal = value code 
{
    <print <current person> "(" <weapon of <current person>> ") accepts" <current guest> "(" <weapon of <current guest>> ") proposal to exchange weapons">;
    
    
    # here we exchange the weapons
    let current weapon=<weapon of <current person>>;
    let weapon of <current person>=<weapon of <current guest>>;
    let weapon of <current guest>=<current weapon>;

    let variable <current person> thinks that <current guest> has proposed him to exchange weapons=value boolean false;    
    
    <print <current person> "exchanges weapons with" <current guest>>;
    
    let variable decision of <current person>=value action no_action;
    
    <resolve the acceptance of the proposal to exchange weapons>;
};




###################



variable perform current person decision goto (A:place):code;
let variable perform current person decision goto (A:place)=value code
{
    let variable current decision = <decision of <current person>>;
    let variable current place = value place [(A:place)];
    let variable current pattern = value action goto <current place>;
    
    #execute <print "check whether" <current person> "decision" <current decision> "equals" <current pattern>>;
        
    execute <compare "action" <current decision> <current pattern>>;
    execute <current person goto current place <the compare result>>;
};


variable perform current person decision tell (A:person) that (B:information):code;
let variable perform current person decision tell (A:person) that (B:information)=value code
{
    let variable current decision = <decision of <current person>>;
    let variable current guest = value person [(A:person)];
    let variable current information = value place [(B:information)];
    let variable current pattern = value action tell <current guest> that <current information>;

    #execute <print "check whether" <current person> "decision" <current decision> "equals" <current pattern>>;    
    
    execute <compare "action" <current decision> <current pattern>>;
    execute <current person tells current guest that current information <the compare result>>;
};

variable perform current person decision ask (A:person) to (B:action):code;
let variable perform current person decision ask (A:person) to (B:action)=value code
{
    let variable current decision = <decision of <current person>>;
    let variable current guest = value person [(A:person)];
    let variable current action = value action [(B:action)];
    let variable current pattern = value action ask <current guest> to <current action>;

    execute <compare "action" <current decision> <current pattern>>;
    execute <current person asks current guest to current action <the compare result>>;    
};

variable perform current person decision ask (A:person) what is his function:code;
let variable perform current person decision ask (A:person) what is his function=value code
{
    let variable current decision = <decision of <current person>>;
    let variable current guest = value person [(A:person)];
    let variable current pattern = value action ask <current guest> what is his function;
    
    execute <compare "action" <current decision> <current pattern>>;
    execute <current person asks current guest what is his function <the compare result>>;    
};

variable perform current person decision ask (A:person) what is his weapon:code;
let variable perform current person decision ask (A:person) what is his weapon=value code
{
    let variable current decision = <decision of <current person>>;
    let variable current guest = value person [(A:person)];
    let variable current pattern = value action ask <current guest> what is his weapon;
    
    execute <compare "action" <current decision> <current pattern>>;
    execute <current person asks current guest what is his weapon <the compare result>>;    
};

variable perform current person decision ask (A:person) whether he is a liar:code;
let variable perform current person decision ask (A:person) whether he is a liar=value code
{
    let variable current decision = <decision of <current person>>;
    let variable current guest = value person [(A:person)];
    let variable current pattern = value action ask <current guest> whether he is a liar;
    
    execute <compare "action" <current decision> <current pattern>>;
    execute <current person asks current guest whether he is a liar <the compare result>>;    
};


variable perform current person decision attack (A:person):code;
let variable perform current person decision attack (A:person)=value code
{
    let variable current decision = <decision of <current person>>;
    let variable current guest = value person [(A:person)];
    let variable current pattern = value action attack <current guest>;
    
    execute <compare "action" <current decision> <current pattern>>;
    execute <current person attacks current guest <the compare result>>;    
};


variable perform current person decision propose (A:person) to exchange weapons:code;
let variable perform current person decision propose (A:person) to exchange weapons=value code
{
    let variable current decision = <decision of <current person>>;
    let variable current guest = value person [(A:person)];
    let variable current pattern = value action propose <current guest> to exchange weapons;
            
    <compare "action" <current decision> <current pattern>>;
    <current person proposes current guest to exchange weapons <the compare result>>;    
};


variable perform current person decision accept (A:person) proposal to exchange weapons:code;
let perform current person decision accept (A:person) proposal to exchange weapons=value code
{
    let current decision = <decision of <current person>>;
    let current guest = value person [(A:person)];
    let current pattern = value action accept <current guest> proposal to exchange weapons;
    
    <for each person <current person> make an asking about weapon text>;
    <for each person <current guest> make an asking about weapon text>;

    <compare "action" <current decision> <current pattern>>;
    <current person accepts current guest proposal to exchange weapons <the compare result>>;        
};

variable perform current person decision answer (A:person) whether I am a liar (ANSWER:boolean):code;
let perform current person decision answer (A:person) whether I am a liar (ANSWER:boolean)=value code
{
    let current decision = <decision of <current person>>;
    let current guest = value person [(A:person)];
    let current answer = value boolean [(ANSWER:boolean)];    
    let current pattern = value action answer <current guest> whether I am a liar <current answer>;
    
    <for each person <current person> make an asking about being a liar text>;
    <for each person <current guest> make an asking about being a liar text>;    
        
    <compare "action" <current decision> <current pattern>>;
    <current person answers current guest whether he is a liar <the compare result>>;
};

variable perform decision for (X:person):code;
let variable perform decision for (X:person)=value code
{
    let variable current person = value person [(X:person)];
    execute <print "perform decision for" <current person>>;
        
    execute <perform current person decision goto (A:place)>;
    execute <perform current person decision tell (A:person) that (B:information)>;
    execute <perform current person decision ask (A:person) to (B:action)>;
    execute <perform current person decision ask (A:person) what is his function>;
    execute <perform current person decision ask (A:person) what is his weapon>;
    execute <perform current person decision ask (A:person) whether he is a liar>;
    execute <perform current person decision answer (A:person) whether I am a liar (ANSWER:boolean)>;
    execute <perform current person decision attack (A:person)>;
    execute <perform current person decision propose (A:person) to exchange weapons>;
    execute <perform current person decision accept (A:person) proposal to exchange weapons>;
};


variable perform all the decisions:code;
let variable perform all the decisions=value code
{
    execute <print "performing all the decisions">;    
    execute <perform decision for (X:person)>;            
};
